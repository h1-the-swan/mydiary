/**
 * Generated by orval v6.14.4 üç∫
 * Do not edit manually.
 * mydiary
 * OpenAPI spec version: 0.1.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation
} from 'react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
export type ReadRecipesListParams = {
offset?: number;
limit?: number;
};

export type ReadDogsListParams = {
offset?: number;
limit?: number;
};

export type ReadPerformSongsListParams = {
offset?: number;
limit?: number;
};

export type GetNextcloudImageNextcloudThumbnailImgGetParams = {
url: string;
};

export type GetNextcloudPhotosThumbnailDimsParams = {
url: string;
};

export type JoplinUpdateNoteParams = {
tz?: string;
};

export type JoplinInitNoteParams = {
tz?: string;
};

export type ReadSpotifyHistoryParams = {
offset?: number;
limit?: number;
};

export type ReadPocketArticlesParams = {
offset?: number;
limit?: number;
status?: number[];
/**
 * Tag names (comma separated
 */
tags?: string;
dateMin?: string;
dateMax?: string;
/**
 * Year added (ignored if dateRange is specified)
 */
year?: number;
};

export type ReadTagsParams = {
offset?: number;
limit?: number;
is_pocket_tag?: boolean;
};

export type ReadGCalEventsParams = {
offset?: number;
limit?: number;
};

export type RefreshGCalTokenParams = {
code: string;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface TagRead {
  name: string;
  is_pocket_tag?: boolean;
  id: number;
  num_pocket_articles?: number;
}

export interface SpotifyTrackBase {
  spotify_id: string;
  name: string;
  artist_name: string;
  uri: string;
}

/**
 * An enumeration.
 */
export type SpotifyContextTypeEnum = typeof SpotifyContextTypeEnum[keyof typeof SpotifyContextTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SpotifyContextTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface SpotifyTrackHistoryRead {
  id: number;
  played_at: string;
  context_uri?: string;
  context_name?: string;
  context_type?: SpotifyContextTypeEnum;
  spotify_id: string;
  track: SpotifyTrackBase;
}

export interface RecipeRead {
  name: string;
  upvotes?: number;
  notes?: string;
  id: number;
}

export interface RecipeCreate {
  name: string;
  upvotes?: number;
  notes?: string;
}

/**
 * An enumeration.
 */
export type PocketStatusEnum = typeof PocketStatusEnum[keyof typeof PocketStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PocketStatusEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface PocketArticleUpdate {
  given_title?: string;
  resolved_title?: string;
  url?: string;
  favorite?: boolean;
  status?: PocketStatusEnum;
  time_added?: string;
  time_updated?: string;
  time_read?: string;
  time_favorited?: string;
  listen_duration_estimate?: number;
  word_count?: number;
  excerpt?: string;
  top_image_url?: string;
  pocket_tags?: string[];
}

export interface PocketArticleRead {
  given_title: string;
  resolved_title: string;
  url: string;
  favorite: boolean;
  status: PocketStatusEnum;
  time_added?: string;
  time_updated?: string;
  time_read?: string;
  time_favorited?: string;
  listen_duration_estimate?: number;
  word_count?: number;
  excerpt?: string;
  top_image_url?: string;
  id: number;
  tags: TagRead[];
}

export interface PerformSongUpdate {
  name?: string;
  artist_name?: string;
  learned?: boolean;
  spotify_id?: string;
  notes?: string;
  perform_url?: string;
  created_at?: string;
  key?: string;
  capo?: number;
  lyrics?: string;
  learned_dt?: string;
}

export interface PerformSongRead {
  name: string;
  artist_name?: string;
  learned?: boolean;
  spotify_id?: string;
  notes?: string;
  perform_url?: string;
  created_at?: string;
  key?: string;
  capo?: number;
  lyrics?: string;
  learned_dt?: string;
  id: number;
}

export interface PerformSongCreate {
  name: string;
  artist_name?: string;
  learned?: boolean;
  spotify_id?: string;
  notes?: string;
  perform_url?: string;
  created_at?: string;
  key?: string;
  capo?: number;
  lyrics?: string;
  learned_dt?: string;
}

export interface JoplinNote {
  id: string;
  parent_id: string;
  title: string;
  body: string;
  created_time: string;
  updated_time: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GooglePhotosThumbnail {
  baseUrl: string;
  width: number;
  height: number;
}

export interface GoogleCalendarEventRead {
  id: string;
  summary: string;
  location?: string;
  description?: string;
  start: string;
  end: string;
  start_timezone: string;
  end_timezone: string;
}

export interface DogUpdate {
  name?: string;
  how_met?: string;
  when_met?: string;
  owners?: string;
  estimated_bday?: string;
  notes?: string;
}

export interface DogRead {
  name: string;
  how_met?: string;
  when_met?: string;
  owners?: string;
  estimated_bday?: string;
  notes?: string;
  id: number;
}

export interface DogCreate {
  name: string;
  how_met?: string;
  when_met?: string;
  owners?: string;
  estimated_bday?: string;
  notes?: string;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


/**
 * @summary Get Gcal Auth Url
 */
export const getGCalAuthUrl = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    return axios.get(
      `/gcal/get_auth_url`,options
    );
  }


export const getGetGCalAuthUrlQueryKey = () => [`/gcal/get_auth_url`] as const;
  

    
export const getGetGCalAuthUrlQueryOptions = <TData = Awaited<ReturnType<typeof getGCalAuthUrl>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGCalAuthUrlQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGCalAuthUrl>>> = ({ signal }) => getGCalAuthUrl({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetGCalAuthUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getGCalAuthUrl>>>
export type GetGCalAuthUrlQueryError = AxiosError<unknown>

export const useGetGCalAuthUrl = <TData = Awaited<ReturnType<typeof getGCalAuthUrl>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGCalAuthUrlQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Refresh Gcal Token
 */
export const refreshGCalToken = (
    params: RefreshGCalTokenParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/gcal/refresh_token`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getRefreshGCalTokenMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshGCalToken>>, {params: RefreshGCalTokenParams}> = (props) => {
          const {params} = props ?? {};

          return  refreshGCalToken(params,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type RefreshGCalTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshGCalToken>>>
    
    export type RefreshGCalTokenMutationError = AxiosError<HTTPValidationError>

    export const useRefreshGCalToken = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getRefreshGCalTokenMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Check Gcal Auth
 */
export const checkGCalAuth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/gcal/check_auth`,undefined,options
    );
  }



export const getCheckGCalAuthMutationOptions = <TError = AxiosError<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,TVariables, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkGCalAuth>>, TVariables> = () => {
          

          return  checkGCalAuth(axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CheckGCalAuthMutationResult = NonNullable<Awaited<ReturnType<typeof checkGCalAuth>>>
    
    export type CheckGCalAuthMutationError = AxiosError<unknown>

    export const useCheckGCalAuth = <TError = AxiosError<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,TVariables, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCheckGCalAuthMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Gcal Events
 */
export const readGCalEvents = (
    params?: ReadGCalEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GoogleCalendarEventRead[]>> => {
    return axios.get(
      `/gcal/events`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadGCalEventsQueryKey = (params?: ReadGCalEventsParams,) => [`/gcal/events`, ...(params ? [params]: [])] as const;
  

    
export const getReadGCalEventsQueryOptions = <TData = Awaited<ReturnType<typeof readGCalEvents>>, TError = AxiosError<HTTPValidationError>>(params?: ReadGCalEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadGCalEventsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readGCalEvents>>> = ({ signal }) => readGCalEvents(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadGCalEventsQueryResult = NonNullable<Awaited<ReturnType<typeof readGCalEvents>>>
export type ReadGCalEventsQueryError = AxiosError<HTTPValidationError>

export const useReadGCalEvents = <TData = Awaited<ReturnType<typeof readGCalEvents>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadGCalEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadGCalEventsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Read Tags
 */
export const readTags = (
    params?: ReadTagsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead[]>> => {
    return axios.get(
      `/tags`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadTagsQueryKey = (params?: ReadTagsParams,) => [`/tags`, ...(params ? [params]: [])] as const;
  

    
export const getReadTagsQueryOptions = <TData = Awaited<ReturnType<typeof readTags>>, TError = AxiosError<HTTPValidationError>>(params?: ReadTagsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadTagsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readTags>>> = ({ signal }) => readTags(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadTagsQueryResult = NonNullable<Awaited<ReturnType<typeof readTags>>>
export type ReadTagsQueryError = AxiosError<HTTPValidationError>

export const useReadTags = <TData = Awaited<ReturnType<typeof readTags>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadTagsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadTagsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Count Pocket Articles
 */
export const countPocketArticles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    return axios.get(
      `/pocket/articles/count`,options
    );
  }


export const getCountPocketArticlesQueryKey = () => [`/pocket/articles/count`] as const;
  

    
export const getCountPocketArticlesQueryOptions = <TData = Awaited<ReturnType<typeof countPocketArticles>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCountPocketArticlesQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof countPocketArticles>>> = ({ signal }) => countPocketArticles({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type CountPocketArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof countPocketArticles>>>
export type CountPocketArticlesQueryError = AxiosError<unknown>

export const useCountPocketArticles = <TData = Awaited<ReturnType<typeof countPocketArticles>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCountPocketArticlesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Read Pocket Articles
 */
export const readPocketArticles = (
    params?: ReadPocketArticlesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead[]>> => {
    return axios.get(
      `/pocket/articles`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadPocketArticlesQueryKey = (params?: ReadPocketArticlesParams,) => [`/pocket/articles`, ...(params ? [params]: [])] as const;
  

    
export const getReadPocketArticlesQueryOptions = <TData = Awaited<ReturnType<typeof readPocketArticles>>, TError = AxiosError<HTTPValidationError>>(params?: ReadPocketArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPocketArticlesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPocketArticles>>> = ({ signal }) => readPocketArticles(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadPocketArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof readPocketArticles>>>
export type ReadPocketArticlesQueryError = AxiosError<HTTPValidationError>

export const useReadPocketArticles = <TData = Awaited<ReturnType<typeof readPocketArticles>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPocketArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPocketArticlesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Update Pocket Article
 */
export const updatePocketArticle = (
    articleId: number,
    pocketArticleUpdate: PocketArticleUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead>> => {
    return axios.patch(
      `/pocket/articles/${articleId}`,
      pocketArticleUpdate,options
    );
  }



export const getUpdatePocketArticleMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePocketArticle>>, {articleId: number;data: PocketArticleUpdate}> = (props) => {
          const {articleId,data} = props ?? {};

          return  updatePocketArticle(articleId,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdatePocketArticleMutationResult = NonNullable<Awaited<ReturnType<typeof updatePocketArticle>>>
    export type UpdatePocketArticleMutationBody = PocketArticleUpdate
    export type UpdatePocketArticleMutationError = AxiosError<HTTPValidationError>

    export const useUpdatePocketArticle = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUpdatePocketArticleMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Spotify History
 */
export const readSpotifyHistory = (
    params?: ReadSpotifyHistoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpotifyTrackHistoryRead[]>> => {
    return axios.get(
      `/spotify/history`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadSpotifyHistoryQueryKey = (params?: ReadSpotifyHistoryParams,) => [`/spotify/history`, ...(params ? [params]: [])] as const;
  

    
export const getReadSpotifyHistoryQueryOptions = <TData = Awaited<ReturnType<typeof readSpotifyHistory>>, TError = AxiosError<HTTPValidationError>>(params?: ReadSpotifyHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadSpotifyHistoryQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readSpotifyHistory>>> = ({ signal }) => readSpotifyHistory(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadSpotifyHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof readSpotifyHistory>>>
export type ReadSpotifyHistoryQueryError = AxiosError<HTTPValidationError>

export const useReadSpotifyHistory = <TData = Awaited<ReturnType<typeof readSpotifyHistory>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadSpotifyHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadSpotifyHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Spotify History Count
 */
export const spotifyHistoryCount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    return axios.get(
      `/spotify/history/count`,options
    );
  }


export const getSpotifyHistoryCountQueryKey = () => [`/spotify/history/count`] as const;
  

    
export const getSpotifyHistoryCountQueryOptions = <TData = Awaited<ReturnType<typeof spotifyHistoryCount>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpotifyHistoryCountQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof spotifyHistoryCount>>> = ({ signal }) => spotifyHistoryCount({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SpotifyHistoryCountQueryResult = NonNullable<Awaited<ReturnType<typeof spotifyHistoryCount>>>
export type SpotifyHistoryCountQueryError = AxiosError<unknown>

export const useSpotifyHistoryCount = <TData = Awaited<ReturnType<typeof spotifyHistoryCount>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpotifyHistoryCountQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Get Spotify Image Url
 */
export const getSpotifyImageUrl = (
    trackId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    return axios.get(
      `/spotify/album_image_url/${trackId}`,options
    );
  }


export const getGetSpotifyImageUrlQueryKey = (trackId: string,) => [`/spotify/album_image_url/${trackId}`] as const;
  

    
export const getGetSpotifyImageUrlQueryOptions = <TData = Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError = AxiosError<HTTPValidationError>>(trackId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpotifyImageUrlQueryKey(trackId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpotifyImageUrl>>> = ({ signal }) => getSpotifyImageUrl(trackId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(trackId), ...queryOptions}}

export type GetSpotifyImageUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getSpotifyImageUrl>>>
export type GetSpotifyImageUrlQueryError = AxiosError<HTTPValidationError>

export const useGetSpotifyImageUrl = <TData = Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError = AxiosError<HTTPValidationError>>(
 trackId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpotifyImageUrlQueryOptions(trackId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Joplin Sync
 */
export const joplinSync = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/joplin/sync`,undefined,options
    );
  }



export const getJoplinSyncMutationOptions = <TError = AxiosError<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,TVariables, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,TVariables, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinSync>>, TVariables> = () => {
          

          return  joplinSync(axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type JoplinSyncMutationResult = NonNullable<Awaited<ReturnType<typeof joplinSync>>>
    
    export type JoplinSyncMutationError = AxiosError<unknown>

    export const useJoplinSync = <TError = AxiosError<unknown>,
    TVariables = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,TVariables, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getJoplinSyncMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Joplin Get Note Id
 */
export const joplinGetNoteId = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    return axios.get(
      `/joplin/get_note_id/${dt}`,options
    );
  }


export const getJoplinGetNoteIdQueryKey = (dt: string,) => [`/joplin/get_note_id/${dt}`] as const;
  

    
export const getJoplinGetNoteIdQueryOptions = <TData = Awaited<ReturnType<typeof joplinGetNoteId>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJoplinGetNoteIdQueryKey(dt);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof joplinGetNoteId>>> = ({ signal }) => joplinGetNoteId(dt, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions}}

export type JoplinGetNoteIdQueryResult = NonNullable<Awaited<ReturnType<typeof joplinGetNoteId>>>
export type JoplinGetNoteIdQueryError = AxiosError<HTTPValidationError>

export const useJoplinGetNoteId = <TData = Awaited<ReturnType<typeof joplinGetNoteId>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJoplinGetNoteIdQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Joplin Init Note
 */
export const joplinInitNote = (
    dt: string,
    params?: JoplinInitNoteParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/joplin/init_note/${dt}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getJoplinInitNoteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinInitNote>>, {dt: string;params?: JoplinInitNoteParams}> = (props) => {
          const {dt,params} = props ?? {};

          return  joplinInitNote(dt,params,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type JoplinInitNoteMutationResult = NonNullable<Awaited<ReturnType<typeof joplinInitNote>>>
    
    export type JoplinInitNoteMutationError = AxiosError<HTTPValidationError>

    export const useJoplinInitNote = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getJoplinInitNoteMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Joplin Get Note
 */
export const joplinGetNote = (
    noteId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoplinNote>> => {
    return axios.get(
      `/joplin/get_note/${noteId}`,options
    );
  }


export const getJoplinGetNoteQueryKey = (noteId: string,) => [`/joplin/get_note/${noteId}`] as const;
  

    
export const getJoplinGetNoteQueryOptions = <TData = Awaited<ReturnType<typeof joplinGetNote>>, TError = AxiosError<HTTPValidationError>>(noteId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJoplinGetNoteQueryKey(noteId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof joplinGetNote>>> = ({ signal }) => joplinGetNote(noteId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(noteId), ...queryOptions}}

export type JoplinGetNoteQueryResult = NonNullable<Awaited<ReturnType<typeof joplinGetNote>>>
export type JoplinGetNoteQueryError = AxiosError<HTTPValidationError>

export const useJoplinGetNote = <TData = Awaited<ReturnType<typeof joplinGetNote>>, TError = AxiosError<HTTPValidationError>>(
 noteId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJoplinGetNoteQueryOptions(noteId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Joplin Update Note
 */
export const joplinUpdateNote = (
    dt: string,
    params?: JoplinUpdateNoteParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/joplin/update_note/${dt}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getJoplinUpdateNoteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinUpdateNote>>, {dt: string;params?: JoplinUpdateNoteParams}> = (props) => {
          const {dt,params} = props ?? {};

          return  joplinUpdateNote(dt,params,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type JoplinUpdateNoteMutationResult = NonNullable<Awaited<ReturnType<typeof joplinUpdateNote>>>
    
    export type JoplinUpdateNoteMutationError = AxiosError<HTTPValidationError>

    export const useJoplinUpdateNote = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getJoplinUpdateNoteMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Google Photos Thumbnails Url
 */
export const googlePhotosThumbnailUrls = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GooglePhotosThumbnail[]>> => {
    return axios.get(
      `/googlephotos/thumbnails/${dt}`,options
    );
  }


export const getGooglePhotosThumbnailUrlsQueryKey = (dt: string,) => [`/googlephotos/thumbnails/${dt}`] as const;
  

    
export const getGooglePhotosThumbnailUrlsQueryOptions = <TData = Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGooglePhotosThumbnailUrlsQueryKey(dt);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>> = ({ signal }) => googlePhotosThumbnailUrls(dt, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions}}

export type GooglePhotosThumbnailUrlsQueryResult = NonNullable<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>>
export type GooglePhotosThumbnailUrlsQueryError = AxiosError<HTTPValidationError>

export const useGooglePhotosThumbnailUrls = <TData = Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGooglePhotosThumbnailUrlsQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Google Photos Add To Joplin
 */
export const googlePhotosAddToJoplin = (
    noteId: string,
    googlePhotosThumbnail: GooglePhotosThumbnail[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/googlephotos/add_to_joplin/${noteId}`,
      googlePhotosThumbnail,options
    );
  }



export const getGooglePhotosAddToJoplinMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, {noteId: string;data: GooglePhotosThumbnail[]}> = (props) => {
          const {noteId,data} = props ?? {};

          return  googlePhotosAddToJoplin(noteId,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type GooglePhotosAddToJoplinMutationResult = NonNullable<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>>
    export type GooglePhotosAddToJoplinMutationBody = GooglePhotosThumbnail[]
    export type GooglePhotosAddToJoplinMutationError = AxiosError<HTTPValidationError>

    export const useGooglePhotosAddToJoplin = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getGooglePhotosAddToJoplinMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Nextcloud Photos Thumbnails Url
 */
export const nextcloudPhotosThumbnailUrls = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    return axios.get(
      `/nextcloud/thumbnails/${dt}`,options
    );
  }


export const getNextcloudPhotosThumbnailUrlsQueryKey = (dt: string,) => [`/nextcloud/thumbnails/${dt}`] as const;
  

    
export const getNextcloudPhotosThumbnailUrlsQueryOptions = <TData = Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNextcloudPhotosThumbnailUrlsQueryKey(dt);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>> = ({ signal }) => nextcloudPhotosThumbnailUrls(dt, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions}}

export type NextcloudPhotosThumbnailUrlsQueryResult = NonNullable<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>>
export type NextcloudPhotosThumbnailUrlsQueryError = AxiosError<HTTPValidationError>

export const useNextcloudPhotosThumbnailUrls = <TData = Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getNextcloudPhotosThumbnailUrlsQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Get Nextcloud Thumbnail Dims
 */
export const getNextcloudPhotosThumbnailDims = (
    params: GetNextcloudPhotosThumbnailDimsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown[]>> => {
    return axios.get(
      `/nextcloud/thumbnail_dims`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetNextcloudPhotosThumbnailDimsQueryKey = (params: GetNextcloudPhotosThumbnailDimsParams,) => [`/nextcloud/thumbnail_dims`, ...(params ? [params]: [])] as const;
  

    
export const getGetNextcloudPhotosThumbnailDimsQueryOptions = <TData = Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError = AxiosError<HTTPValidationError>>(params: GetNextcloudPhotosThumbnailDimsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextcloudPhotosThumbnailDimsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>> = ({ signal }) => getNextcloudPhotosThumbnailDims(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetNextcloudPhotosThumbnailDimsQueryResult = NonNullable<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>>
export type GetNextcloudPhotosThumbnailDimsQueryError = AxiosError<HTTPValidationError>

export const useGetNextcloudPhotosThumbnailDims = <TData = Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError = AxiosError<HTTPValidationError>>(
 params: GetNextcloudPhotosThumbnailDimsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNextcloudPhotosThumbnailDimsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Get Nextcloud Image
 */
export const getNextcloudImageNextcloudThumbnailImgGet = (
    params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.get(
      `/nextcloud/thumbnail_img`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetNextcloudImageNextcloudThumbnailImgGetQueryKey = (params: GetNextcloudImageNextcloudThumbnailImgGetParams,) => [`/nextcloud/thumbnail_img`, ...(params ? [params]: [])] as const;
  

    
export const getGetNextcloudImageNextcloudThumbnailImgGetQueryOptions = <TData = Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError = AxiosError<HTTPValidationError>>(params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextcloudImageNextcloudThumbnailImgGetQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>> = ({ signal }) => getNextcloudImageNextcloudThumbnailImgGet(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetNextcloudImageNextcloudThumbnailImgGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>>
export type GetNextcloudImageNextcloudThumbnailImgGetQueryError = AxiosError<HTTPValidationError>

export const useGetNextcloudImageNextcloudThumbnailImgGet = <TData = Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError = AxiosError<HTTPValidationError>>(
 params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNextcloudImageNextcloudThumbnailImgGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Nextcloud Photos Add To Joplin
 */
export const nextcloudPhotosAddToJoplin = (
    noteId: string,
    nextcloudPhotosAddToJoplinBody: string[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.post(
      `/nextcloud/add_to_joplin/${noteId}`,
      nextcloudPhotosAddToJoplinBody,options
    );
  }



export const getNextcloudPhotosAddToJoplinMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, {noteId: string;data: string[]}> = (props) => {
          const {noteId,data} = props ?? {};

          return  nextcloudPhotosAddToJoplin(noteId,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type NextcloudPhotosAddToJoplinMutationResult = NonNullable<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>>
    export type NextcloudPhotosAddToJoplinMutationBody = string[]
    export type NextcloudPhotosAddToJoplinMutationError = AxiosError<HTTPValidationError>

    export const useNextcloudPhotosAddToJoplin = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getNextcloudPhotosAddToJoplinMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Perform Songs
 */
export const readPerformSongsList = (
    params?: ReadPerformSongsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead[]>> => {
    return axios.get(
      `/performsongs/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadPerformSongsListQueryKey = (params?: ReadPerformSongsListParams,) => [`/performsongs/`, ...(params ? [params]: [])] as const;
  

    
export const getReadPerformSongsListQueryOptions = <TData = Awaited<ReturnType<typeof readPerformSongsList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadPerformSongsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPerformSongsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPerformSongsList>>> = ({ signal }) => readPerformSongsList(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadPerformSongsListQueryResult = NonNullable<Awaited<ReturnType<typeof readPerformSongsList>>>
export type ReadPerformSongsListQueryError = AxiosError<HTTPValidationError>

export const useReadPerformSongsList = <TData = Awaited<ReturnType<typeof readPerformSongsList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPerformSongsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPerformSongsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Create Perform Song
 */
export const createPerformSong = (
    performSongCreate: PerformSongCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    return axios.post(
      `/performsongs/`,
      performSongCreate,options
    );
  }



export const getCreatePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPerformSong>>, {data: PerformSongCreate}> = (props) => {
          const {data} = props ?? {};

          return  createPerformSong(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreatePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof createPerformSong>>>
    export type CreatePerformSongMutationBody = PerformSongCreate
    export type CreatePerformSongMutationError = AxiosError<HTTPValidationError>

    export const useCreatePerformSong = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreatePerformSongMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Perform Song  Count
 */
export const performSongCount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    return axios.get(
      `/performsongs/count`,options
    );
  }


export const getPerformSongCountQueryKey = () => [`/performsongs/count`] as const;
  

    
export const getPerformSongCountQueryOptions = <TData = Awaited<ReturnType<typeof performSongCount>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPerformSongCountQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof performSongCount>>> = ({ signal }) => performSongCount({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type PerformSongCountQueryResult = NonNullable<Awaited<ReturnType<typeof performSongCount>>>
export type PerformSongCountQueryError = AxiosError<unknown>

export const usePerformSongCount = <TData = Awaited<ReturnType<typeof performSongCount>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getPerformSongCountQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Read Perform Song
 */
export const readPerformSong = (
    performSongId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    return axios.get(
      `/performsongs/${performSongId}`,options
    );
  }


export const getReadPerformSongQueryKey = (performSongId: number,) => [`/performsongs/${performSongId}`] as const;
  

    
export const getReadPerformSongQueryOptions = <TData = Awaited<ReturnType<typeof readPerformSong>>, TError = AxiosError<HTTPValidationError>>(performSongId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPerformSongQueryKey(performSongId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPerformSong>>> = ({ signal }) => readPerformSong(performSongId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(performSongId), ...queryOptions}}

export type ReadPerformSongQueryResult = NonNullable<Awaited<ReturnType<typeof readPerformSong>>>
export type ReadPerformSongQueryError = AxiosError<HTTPValidationError>

export const useReadPerformSong = <TData = Awaited<ReturnType<typeof readPerformSong>>, TError = AxiosError<HTTPValidationError>>(
 performSongId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPerformSongQueryOptions(performSongId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Delete Perform Song
 */
export const deletePerformSong = (
    performSongId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.delete(
      `/performsongs/${performSongId}`,options
    );
  }



export const getDeletePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePerformSong>>, {performSongId: number}> = (props) => {
          const {performSongId} = props ?? {};

          return  deletePerformSong(performSongId,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeletePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof deletePerformSong>>>
    
    export type DeletePerformSongMutationError = AxiosError<HTTPValidationError>

    export const useDeletePerformSong = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeletePerformSongMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update Perform Song
 */
export const updatePerformSong = (
    performSongId: number,
    performSongUpdate: PerformSongUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    return axios.patch(
      `/performsongs/${performSongId}`,
      performSongUpdate,options
    );
  }



export const getUpdatePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePerformSong>>, {performSongId: number;data: PerformSongUpdate}> = (props) => {
          const {performSongId,data} = props ?? {};

          return  updatePerformSong(performSongId,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdatePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof updatePerformSong>>>
    export type UpdatePerformSongMutationBody = PerformSongUpdate
    export type UpdatePerformSongMutationError = AxiosError<HTTPValidationError>

    export const useUpdatePerformSong = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUpdatePerformSongMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Dogs
 */
export const readDogsList = (
    params?: ReadDogsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead[]>> => {
    return axios.get(
      `/dogs/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadDogsListQueryKey = (params?: ReadDogsListParams,) => [`/dogs/`, ...(params ? [params]: [])] as const;
  

    
export const getReadDogsListQueryOptions = <TData = Awaited<ReturnType<typeof readDogsList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadDogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDogsListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDogsList>>> = ({ signal }) => readDogsList(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadDogsListQueryResult = NonNullable<Awaited<ReturnType<typeof readDogsList>>>
export type ReadDogsListQueryError = AxiosError<HTTPValidationError>

export const useReadDogsList = <TData = Awaited<ReturnType<typeof readDogsList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadDogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadDogsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Create Dog
 */
export const createDog = (
    dogCreate: DogCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    return axios.post(
      `/dogs/`,
      dogCreate,options
    );
  }



export const getCreateDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDog>>, {data: DogCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDog(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateDogMutationResult = NonNullable<Awaited<ReturnType<typeof createDog>>>
    export type CreateDogMutationBody = DogCreate
    export type CreateDogMutationError = AxiosError<HTTPValidationError>

    export const useCreateDog = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateDogMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Dog
 */
export const readDog = (
    dogId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    return axios.get(
      `/dogs/${dogId}`,options
    );
  }


export const getReadDogQueryKey = (dogId: number,) => [`/dogs/${dogId}`] as const;
  

    
export const getReadDogQueryOptions = <TData = Awaited<ReturnType<typeof readDog>>, TError = AxiosError<HTTPValidationError>>(dogId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDogQueryKey(dogId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDog>>> = ({ signal }) => readDog(dogId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(dogId), ...queryOptions}}

export type ReadDogQueryResult = NonNullable<Awaited<ReturnType<typeof readDog>>>
export type ReadDogQueryError = AxiosError<HTTPValidationError>

export const useReadDog = <TData = Awaited<ReturnType<typeof readDog>>, TError = AxiosError<HTTPValidationError>>(
 dogId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadDogQueryOptions(dogId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Delete Dog
 */
export const deleteDog = (
    dogId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.delete(
      `/dogs/${dogId}`,options
    );
  }



export const getDeleteDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDog>>, {dogId: number}> = (props) => {
          const {dogId} = props ?? {};

          return  deleteDog(dogId,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteDogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDog>>>
    
    export type DeleteDogMutationError = AxiosError<HTTPValidationError>

    export const useDeleteDog = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteDogMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Update Dog
 */
export const updateDog = (
    dogId: number,
    dogUpdate: DogUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    return axios.patch(
      `/dogs/${dogId}`,
      dogUpdate,options
    );
  }



export const getUpdateDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDog>>, {dogId: number;data: DogUpdate}> = (props) => {
          const {dogId,data} = props ?? {};

          return  updateDog(dogId,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type UpdateDogMutationResult = NonNullable<Awaited<ReturnType<typeof updateDog>>>
    export type UpdateDogMutationBody = DogUpdate
    export type UpdateDogMutationError = AxiosError<HTTPValidationError>

    export const useUpdateDog = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getUpdateDogMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Recipes
 */
export const readRecipesList = (
    params?: ReadRecipesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RecipeRead>> => {
    return axios.get(
      `/recipes/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadRecipesListQueryKey = (params?: ReadRecipesListParams,) => [`/recipes/`, ...(params ? [params]: [])] as const;
  

    
export const getReadRecipesListQueryOptions = <TData = Awaited<ReturnType<typeof readRecipesList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadRecipesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRecipesListQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRecipesList>>> = ({ signal }) => readRecipesList(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ReadRecipesListQueryResult = NonNullable<Awaited<ReturnType<typeof readRecipesList>>>
export type ReadRecipesListQueryError = AxiosError<HTTPValidationError>

export const useReadRecipesList = <TData = Awaited<ReturnType<typeof readRecipesList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadRecipesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadRecipesListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


/**
 * @summary Create Recipe
 */
export const createRecipe = (
    recipeCreate: RecipeCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RecipeRead>> => {
    return axios.post(
      `/recipes/`,
      recipeCreate,options
    );
  }



export const getCreateRecipeMutationOptions = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRecipe>>, {data: RecipeCreate}> = (props) => {
          const {data} = props ?? {};

          return  createRecipe(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type CreateRecipeMutationResult = NonNullable<Awaited<ReturnType<typeof createRecipe>>>
    export type CreateRecipeMutationBody = RecipeCreate
    export type CreateRecipeMutationError = AxiosError<HTTPValidationError>

    export const useCreateRecipe = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getCreateRecipeMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Send Api Json
 */
export const sendApiJsonGenerateOpenapiJsonGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    return axios.get(
      `/generate_openapi_json`,options
    );
  }


export const getSendApiJsonGenerateOpenapiJsonGetQueryKey = () => [`/generate_openapi_json`] as const;
  

    
export const getSendApiJsonGenerateOpenapiJsonGetQueryOptions = <TData = Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSendApiJsonGenerateOpenapiJsonGetQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>> = ({ signal }) => sendApiJsonGenerateOpenapiJsonGet({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SendApiJsonGenerateOpenapiJsonGetQueryResult = NonNullable<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>>
export type SendApiJsonGenerateOpenapiJsonGetQueryError = AxiosError<unknown>

export const useSendApiJsonGenerateOpenapiJsonGet = <TData = Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSendApiJsonGenerateOpenapiJsonGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}


