/**
 * Generated by orval v6.6.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import axios,{
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  UseQueryOptions,
  QueryFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
export type ReadPocketArticlesPocketArticlesGetParams = { offset?: number; limit?: number; status?: number };

export type ReadTagsTagsGetParams = { offset?: number; limit?: number };

export type ReadGcalEventsGcalEventsGetParams = { offset?: number; limit?: number };

export interface ValidationError {
  loc: string[];
  msg: string;
  type: string;
}

export interface TagRead {
  id: number;
  name: string;
  is_pocket_tag?: boolean;
}

/**
 * An enumeration.
 */
export type PocketStatusEnum = 0 | 1 | 2;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PocketStatusEnum = {
  NUMBER_0: 0 as PocketStatusEnum,
  NUMBER_1: 1 as PocketStatusEnum,
  NUMBER_2: 2 as PocketStatusEnum,
};

export interface PocketArticleRead {
  id: number;
  given_title: string;
  resolved_title: string;
  url: string;
  favorite: boolean;
  status: PocketStatusEnum;
  time_added?: string;
  time_updated?: string;
  time_read?: string;
  time_favorited?: string;
  listen_duration_estimate?: number;
  word_count?: number;
  excerpt?: string;
  top_image_url?: string;
  tags: TagRead[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GoogleCalendarEventRead {
  id: string;
  summary: string;
  location?: string;
  description?: string;
  start: string;
  end: string;
  start_timezone: string;
  end_timezone: string;
}



// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


/**
 * @summary Read Gcal Events
 */
export const readGcalEventsGcalEventsGet = (
    params?: ReadGcalEventsGcalEventsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GoogleCalendarEventRead[]>> => {
    return axios.get(
      `/gcal/events`,{
        params,
    ...options}
    );
  }


export const getReadGcalEventsGcalEventsGetQueryKey = (params?: ReadGcalEventsGcalEventsGetParams,) => [`/gcal/events`, ...(params ? [params]: [])];

    
export const useReadGcalEventsGcalEventsGet = <TData = AsyncReturnType<typeof readGcalEventsGcalEventsGet>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadGcalEventsGcalEventsGetParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readGcalEventsGcalEventsGet>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadGcalEventsGcalEventsGetQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readGcalEventsGcalEventsGet>> = () => readGcalEventsGcalEventsGet(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readGcalEventsGcalEventsGet>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


/**
 * @summary Read Tags
 */
export const readTagsTagsGet = (
    params?: ReadTagsTagsGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead[]>> => {
    return axios.get(
      `/tags`,{
        params,
    ...options}
    );
  }


export const getReadTagsTagsGetQueryKey = (params?: ReadTagsTagsGetParams,) => [`/tags`, ...(params ? [params]: [])];

    
export const useReadTagsTagsGet = <TData = AsyncReturnType<typeof readTagsTagsGet>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadTagsTagsGetParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readTagsTagsGet>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadTagsTagsGetQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readTagsTagsGet>> = () => readTagsTagsGet(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readTagsTagsGet>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


/**
 * @summary Read Pocket Articles
 */
export const readPocketArticlesPocketArticlesGet = (
    params?: ReadPocketArticlesPocketArticlesGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead[]>> => {
    return axios.get(
      `/pocket/articles`,{
        params,
    ...options}
    );
  }


export const getReadPocketArticlesPocketArticlesGetQueryKey = (params?: ReadPocketArticlesPocketArticlesGetParams,) => [`/pocket/articles`, ...(params ? [params]: [])];

    
export const useReadPocketArticlesPocketArticlesGet = <TData = AsyncReturnType<typeof readPocketArticlesPocketArticlesGet>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPocketArticlesPocketArticlesGetParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readPocketArticlesPocketArticlesGet>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadPocketArticlesPocketArticlesGetQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readPocketArticlesPocketArticlesGet>> = () => readPocketArticlesPocketArticlesGet(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readPocketArticlesPocketArticlesGet>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


