/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * mydiary
 * OpenAPI spec version: 0.1.0
 */
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import {
  useMutation,
  useQuery
} from 'react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from 'react-query'
export type SendApiJsonGenerateOpenapiJsonGet200 = {};

export type ReadRecipesListParams = {
offset?: number;
limit?: number;
};

export type DeleteDog200 = {};

export type ReadDogsListParams = {
offset?: number;
limit?: number;
};

export type DeletePerformSong200 = {};

export type ReadPerformSongsListParams = {
offset?: number;
limit?: number;
};

export type NextcloudPhotosAddToJoplin200 = {};

export type GetNextcloudImageNextcloudThumbnailImgGet200One = {};

export type GetNextcloudImageNextcloudThumbnailImgGetParams = {
url: string;
};

export type GetNextcloudPhotosThumbnailDimsParams = {
url: string;
};

export type GooglePhotosAddToJoplin200 = {};

export type JoplinUpdateNote200 = {};

export type JoplinUpdateNoteParams = {
tz?: string;
};

export type DayInitMarkdown200 = {};

export type DayInitMarkdownParams = {
tz?: string;
};

export type JoplinInitNote200 = {};

export type JoplinInitNoteParams = {
tz?: string;
post_sync?: {};
};

export type JoplinSync200 = {};

export type ReadSpotifyHistoryParams = {
offset?: number;
limit?: number;
};

export type ReadPocketArticlesParams = {
offset?: number;
limit?: number;
status?: number[] | null;
/**
 * Tag names (comma separated
 */
tags?: string | null;
dateMin?: string | null;
dateMax?: string | null;
/**
 * Year added (ignored if dateRange is specified)
 */
year?: number | null;
};

export type ReadTagsParams = {
offset?: number;
limit?: number;
is_pocket_tag?: boolean | null;
};

export type ReadGCalEventsParams = {
offset?: number;
limit?: number;
};

export type CheckGCalAuth200 = {};

export type RefreshGCalToken200 = {};

export type RefreshGCalTokenParams = {
code: string;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type TagReadNumPocketArticles = number | null;

export interface TagRead {
  id_: number;
  is_pocket_tag?: boolean;
  name: string;
  num_pocket_articles?: TagReadNumPocketArticles;
}

export type SpotifyTrackHistoryReadId = number | null;

export type SpotifyTrackHistoryReadContextUri = string | null;

export type SpotifyTrackHistoryReadContextType = number | null;

export type SpotifyTrackHistoryReadContextName = string | null;

export interface SpotifyTrackBase {
  artist_name: string;
  name: string;
  spotify_id: string;
  uri: string;
}

export interface SpotifyTrackHistoryRead {
  context_name?: SpotifyTrackHistoryReadContextName;
  context_type?: SpotifyTrackHistoryReadContextType;
  context_uri?: SpotifyTrackHistoryReadContextUri;
  id?: SpotifyTrackHistoryReadId;
  id_: number;
  played_at: string;
  spotify_id: string;
  track: SpotifyTrackBase;
}

export type RecipeReadNotes = string | null;

export interface RecipeRead {
  id: number;
  name: string;
  notes?: RecipeReadNotes;
  upvotes?: number;
}

export type RecipeCreateNotes = string | null;

export interface RecipeCreate {
  name: string;
  notes?: RecipeCreateNotes;
  upvotes?: number;
}

export type PocketStatusEnum = typeof PocketStatusEnum[keyof typeof PocketStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PocketStatusEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export type PocketArticleUpdateWordCount = number | null;

export type PocketArticleUpdateUrl = string | null;

export type PocketArticleUpdateTopImageUrl = string | null;

export type PocketArticleUpdateTimeUpdated = string | null;

export type PocketArticleUpdateTimeRead = string | null;

export type PocketArticleUpdateTimeFavorited = string | null;

export type PocketArticleUpdateTimeAdded = string | null;

export type PocketArticleUpdateStatus = PocketStatusEnum | null;

export type PocketArticleUpdateResolvedTitle = string | null;

export type PocketArticleUpdatePocketTags = string[] | null;

export type PocketArticleUpdateListenDurationEstimate = number | null;

export type PocketArticleUpdateGivenTitle = string | null;

export type PocketArticleUpdateFavorite = boolean | null;

export type PocketArticleUpdateExcerpt = string | null;

export interface PocketArticleUpdate {
  excerpt?: PocketArticleUpdateExcerpt;
  favorite?: PocketArticleUpdateFavorite;
  given_title?: PocketArticleUpdateGivenTitle;
  listen_duration_estimate?: PocketArticleUpdateListenDurationEstimate;
  pocket_tags?: PocketArticleUpdatePocketTags;
  resolved_title?: PocketArticleUpdateResolvedTitle;
  status: PocketArticleUpdateStatus;
  time_added?: PocketArticleUpdateTimeAdded;
  time_favorited?: PocketArticleUpdateTimeFavorited;
  time_read?: PocketArticleUpdateTimeRead;
  time_updated?: PocketArticleUpdateTimeUpdated;
  top_image_url?: PocketArticleUpdateTopImageUrl;
  url?: PocketArticleUpdateUrl;
  word_count?: PocketArticleUpdateWordCount;
}

export type PocketArticleReadWordCount = number | null;

export type PocketArticleReadTopImageUrl = string | null;

export type PocketArticleReadTimeUpdated = string | null;

export type PocketArticleReadTimeRead = string | null;

export type PocketArticleReadTimeFavorited = string | null;

export type PocketArticleReadTimeAdded = string | null;

export type PocketArticleReadListenDurationEstimate = number | null;

export type PocketArticleReadExcerpt = string | null;

export interface PocketArticleRead {
  excerpt?: PocketArticleReadExcerpt;
  favorite: boolean;
  given_title: string;
  id: number;
  listen_duration_estimate?: PocketArticleReadListenDurationEstimate;
  resolved_title: string;
  status: string;
  tags_: TagRead[];
  time_added?: PocketArticleReadTimeAdded;
  time_favorited?: PocketArticleReadTimeFavorited;
  time_read?: PocketArticleReadTimeRead;
  time_updated?: PocketArticleReadTimeUpdated;
  top_image_url?: PocketArticleReadTopImageUrl;
  url: string;
  word_count?: PocketArticleReadWordCount;
}

export type PerformSongUpdateSpotifyId = string | null;

export type PerformSongUpdatePerformUrl = string | null;

export type PerformSongUpdateNotes = string | null;

export type PerformSongUpdateName = string | null;

export type PerformSongUpdateLyrics = string | null;

export type PerformSongUpdateLearnedDt = string | null;

export type PerformSongUpdateLearned = boolean | null;

export type PerformSongUpdateKey = string | null;

export type PerformSongUpdateCreatedAt = string | null;

export type PerformSongUpdateCapo = number | null;

export type PerformSongUpdateArtistName = string | null;

export interface PerformSongUpdate {
  artist_name?: PerformSongUpdateArtistName;
  capo: PerformSongUpdateCapo;
  created_at?: PerformSongUpdateCreatedAt;
  key: PerformSongUpdateKey;
  learned?: PerformSongUpdateLearned;
  learned_dt?: PerformSongUpdateLearnedDt;
  lyrics: PerformSongUpdateLyrics;
  name?: PerformSongUpdateName;
  notes?: PerformSongUpdateNotes;
  perform_url?: PerformSongUpdatePerformUrl;
  spotify_id?: PerformSongUpdateSpotifyId;
}

export type PerformSongReadSpotifyId = string | null;

export type PerformSongReadPerformUrl = string | null;

export type PerformSongReadNotes = string | null;

export type PerformSongReadLyrics = string | null;

export type PerformSongReadLearnedDt = string | null;

export type PerformSongReadKey = string | null;

export type PerformSongReadCreatedAt = string | null;

export type PerformSongReadCapo = number | null;

export type PerformSongReadArtistName = string | null;

export interface PerformSongRead {
  artist_name?: PerformSongReadArtistName;
  capo?: PerformSongReadCapo;
  created_at?: PerformSongReadCreatedAt;
  id: number;
  key?: PerformSongReadKey;
  learned?: boolean;
  learned_dt?: PerformSongReadLearnedDt;
  lyrics?: PerformSongReadLyrics;
  name: string;
  notes?: PerformSongReadNotes;
  perform_url?: PerformSongReadPerformUrl;
  spotify_id?: PerformSongReadSpotifyId;
}

export type PerformSongCreateSpotifyId = string | null;

export type PerformSongCreatePerformUrl = string | null;

export type PerformSongCreateNotes = string | null;

export type PerformSongCreateLyrics = string | null;

export type PerformSongCreateLearnedDt = string | null;

export type PerformSongCreateKey = string | null;

export type PerformSongCreateCreatedAt = string | null;

export type PerformSongCreateCapo = number | null;

export type PerformSongCreateArtistName = string | null;

export interface PerformSongCreate {
  artist_name?: PerformSongCreateArtistName;
  capo?: PerformSongCreateCapo;
  created_at?: PerformSongCreateCreatedAt;
  key?: PerformSongCreateKey;
  learned?: boolean;
  learned_dt?: PerformSongCreateLearnedDt;
  lyrics?: PerformSongCreateLyrics;
  name: string;
  notes?: PerformSongCreateNotes;
  perform_url?: PerformSongCreatePerformUrl;
  spotify_id?: PerformSongCreateSpotifyId;
}

export interface JoplinNote {
  body: string;
  created_time: string;
  id: string;
  parent_id: string;
  title: string;
  updated_time: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GooglePhotosThumbnail {
  baseUrl: string;
  height: number;
  width: number;
}

export type GoogleCalendarEventReadLocation = string | null;

export type GoogleCalendarEventReadDescription = string | null;

export interface GoogleCalendarEventRead {
  description?: GoogleCalendarEventReadDescription;
  end?: string;
  end_timezone?: string;
  id?: string;
  location?: GoogleCalendarEventReadLocation;
  start?: string;
  start_timezone?: string;
  summary?: string;
}

export type DogUpdateWhenMet = string | null;

export type DogUpdateOwners = string | null;

export type DogUpdateNotes = string | null;

export type DogUpdateName = string | null;

export type DogUpdateHowMet = string | null;

export type DogUpdateEstimatedBday = string | null;

export interface DogUpdate {
  estimated_bday?: DogUpdateEstimatedBday;
  how_met?: DogUpdateHowMet;
  name?: DogUpdateName;
  notes?: DogUpdateNotes;
  owners?: DogUpdateOwners;
  when_met?: DogUpdateWhenMet;
}

export type DogReadWhenMet = string | null;

export type DogReadOwners = string | null;

export type DogReadNotes = string | null;

export type DogReadHowMet = string | null;

export type DogReadEstimatedBday = string | null;

export interface DogRead {
  estimated_bday?: DogReadEstimatedBday;
  how_met?: DogReadHowMet;
  id: number;
  name: string;
  notes?: DogReadNotes;
  owners?: DogReadOwners;
  when_met?: DogReadWhenMet;
}

export type DogCreateWhenMet = string | null;

export type DogCreateOwners = string | null;

export type DogCreateNotes = string | null;

export type DogCreateHowMet = string | null;

export type DogCreateEstimatedBday = string | null;

export interface DogCreate {
  estimated_bday?: DogCreateEstimatedBday;
  how_met?: DogCreateHowMet;
  name: string;
  notes?: DogCreateNotes;
  owners?: DogCreateOwners;
  when_met?: DogCreateWhenMet;
}





/**
 * @summary Get Gcal Auth Url
 */
export const getGCalAuthUrl = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `/gcal/get_auth_url`,options
    );
  }


export const getGetGCalAuthUrlQueryKey = () => {
    return [`/gcal/get_auth_url`] as const;
    }

    
export const getGetGCalAuthUrlQueryOptions = <TData = Awaited<ReturnType<typeof getGCalAuthUrl>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGCalAuthUrlQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGCalAuthUrl>>> = ({ signal }) => getGCalAuthUrl({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGCalAuthUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getGCalAuthUrl>>>
export type GetGCalAuthUrlQueryError = AxiosError<unknown>

/**
 * @summary Get Gcal Auth Url
 */
export const useGetGCalAuthUrl = <TData = Awaited<ReturnType<typeof getGCalAuthUrl>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGCalAuthUrl>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGCalAuthUrlQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Refresh Gcal Token
 */
export const refreshGCalToken = (
    params: RefreshGCalTokenParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RefreshGCalToken200>> => {
    
    return axios.post(
      `/gcal/refresh_token`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getRefreshGCalTokenMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshGCalToken>>, {params: RefreshGCalTokenParams}> = (props) => {
          const {params} = props ?? {};

          return  refreshGCalToken(params,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type RefreshGCalTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshGCalToken>>>
    
    export type RefreshGCalTokenMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Refresh Gcal Token
 */
export const useRefreshGCalToken = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshGCalToken>>, TError,{params: RefreshGCalTokenParams}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getRefreshGCalTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Check Gcal Auth
 */
export const checkGCalAuth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CheckGCalAuth200>> => {
    
    return axios.post(
      `/gcal/check_auth`,undefined,options
    );
  }



export const getCheckGCalAuthMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,void, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkGCalAuth>>, void> = () => {
          

          return  checkGCalAuth(axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CheckGCalAuthMutationResult = NonNullable<Awaited<ReturnType<typeof checkGCalAuth>>>
    
    export type CheckGCalAuthMutationError = AxiosError<unknown>

    /**
 * @summary Check Gcal Auth
 */
export const useCheckGCalAuth = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkGCalAuth>>, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getCheckGCalAuthMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Gcal Events
 */
export const readGCalEvents = (
    params?: ReadGCalEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GoogleCalendarEventRead[]>> => {
    
    return axios.get(
      `/gcal/events`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadGCalEventsQueryKey = (params?: ReadGCalEventsParams,) => {
    return [`/gcal/events`, ...(params ? [params]: [])] as const;
    }

    
export const getReadGCalEventsQueryOptions = <TData = Awaited<ReturnType<typeof readGCalEvents>>, TError = AxiosError<HTTPValidationError>>(params?: ReadGCalEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadGCalEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readGCalEvents>>> = ({ signal }) => readGCalEvents(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadGCalEventsQueryResult = NonNullable<Awaited<ReturnType<typeof readGCalEvents>>>
export type ReadGCalEventsQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Gcal Events
 */
export const useReadGCalEvents = <TData = Awaited<ReturnType<typeof readGCalEvents>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadGCalEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readGCalEvents>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadGCalEventsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Tags
 */
export const readTags = (
    params?: ReadTagsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead[]>> => {
    
    return axios.get(
      `/tags`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadTagsQueryKey = (params?: ReadTagsParams,) => {
    return [`/tags`, ...(params ? [params]: [])] as const;
    }

    
export const getReadTagsQueryOptions = <TData = Awaited<ReturnType<typeof readTags>>, TError = AxiosError<HTTPValidationError>>(params?: ReadTagsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadTagsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readTags>>> = ({ signal }) => readTags(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadTagsQueryResult = NonNullable<Awaited<ReturnType<typeof readTags>>>
export type ReadTagsQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Tags
 */
export const useReadTags = <TData = Awaited<ReturnType<typeof readTags>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadTagsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readTags>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadTagsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Count Pocket Articles
 */
export const countPocketArticles = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.get(
      `/pocket/articles/count`,options
    );
  }


export const getCountPocketArticlesQueryKey = () => {
    return [`/pocket/articles/count`] as const;
    }

    
export const getCountPocketArticlesQueryOptions = <TData = Awaited<ReturnType<typeof countPocketArticles>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCountPocketArticlesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof countPocketArticles>>> = ({ signal }) => countPocketArticles({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData> & { queryKey: QueryKey }
}

export type CountPocketArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof countPocketArticles>>>
export type CountPocketArticlesQueryError = AxiosError<unknown>

/**
 * @summary Count Pocket Articles
 */
export const useCountPocketArticles = <TData = Awaited<ReturnType<typeof countPocketArticles>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof countPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCountPocketArticlesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Pocket Articles
 */
export const readPocketArticles = (
    params?: ReadPocketArticlesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead[]>> => {
    
    return axios.get(
      `/pocket/articles`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadPocketArticlesQueryKey = (params?: ReadPocketArticlesParams,) => {
    return [`/pocket/articles`, ...(params ? [params]: [])] as const;
    }

    
export const getReadPocketArticlesQueryOptions = <TData = Awaited<ReturnType<typeof readPocketArticles>>, TError = AxiosError<HTTPValidationError>>(params?: ReadPocketArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPocketArticlesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPocketArticles>>> = ({ signal }) => readPocketArticles(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadPocketArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof readPocketArticles>>>
export type ReadPocketArticlesQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Pocket Articles
 */
export const useReadPocketArticles = <TData = Awaited<ReturnType<typeof readPocketArticles>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPocketArticlesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPocketArticles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPocketArticlesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Pocket Article
 */
export const updatePocketArticle = (
    articleId: number,
    pocketArticleUpdate: PocketArticleUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead>> => {
    
    return axios.patch(
      `/pocket/articles/${articleId}`,
      pocketArticleUpdate,options
    );
  }



export const getUpdatePocketArticleMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePocketArticle>>, {articleId: number;data: PocketArticleUpdate}> = (props) => {
          const {articleId,data} = props ?? {};

          return  updatePocketArticle(articleId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdatePocketArticleMutationResult = NonNullable<Awaited<ReturnType<typeof updatePocketArticle>>>
    export type UpdatePocketArticleMutationBody = PocketArticleUpdate
    export type UpdatePocketArticleMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Pocket Article
 */
export const useUpdatePocketArticle = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePocketArticle>>, TError,{articleId: number;data: PocketArticleUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getUpdatePocketArticleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Spotify History
 */
export const readSpotifyHistory = (
    params?: ReadSpotifyHistoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SpotifyTrackHistoryRead[]>> => {
    
    return axios.get(
      `/spotify/history`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadSpotifyHistoryQueryKey = (params?: ReadSpotifyHistoryParams,) => {
    return [`/spotify/history`, ...(params ? [params]: [])] as const;
    }

    
export const getReadSpotifyHistoryQueryOptions = <TData = Awaited<ReturnType<typeof readSpotifyHistory>>, TError = AxiosError<HTTPValidationError>>(params?: ReadSpotifyHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadSpotifyHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readSpotifyHistory>>> = ({ signal }) => readSpotifyHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadSpotifyHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof readSpotifyHistory>>>
export type ReadSpotifyHistoryQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Spotify History
 */
export const useReadSpotifyHistory = <TData = Awaited<ReturnType<typeof readSpotifyHistory>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadSpotifyHistoryParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readSpotifyHistory>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadSpotifyHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Spotify History Count
 */
export const spotifyHistoryCount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.get(
      `/spotify/history/count`,options
    );
  }


export const getSpotifyHistoryCountQueryKey = () => {
    return [`/spotify/history/count`] as const;
    }

    
export const getSpotifyHistoryCountQueryOptions = <TData = Awaited<ReturnType<typeof spotifyHistoryCount>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSpotifyHistoryCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof spotifyHistoryCount>>> = ({ signal }) => spotifyHistoryCount({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData> & { queryKey: QueryKey }
}

export type SpotifyHistoryCountQueryResult = NonNullable<Awaited<ReturnType<typeof spotifyHistoryCount>>>
export type SpotifyHistoryCountQueryError = AxiosError<unknown>

/**
 * @summary Spotify History Count
 */
export const useSpotifyHistoryCount = <TData = Awaited<ReturnType<typeof spotifyHistoryCount>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof spotifyHistoryCount>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSpotifyHistoryCountQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Spotify Image Url
 */
export const getSpotifyImageUrl = (
    trackId: string | null, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `/spotify/album_image_url/${trackId}`,options
    );
  }


export const getGetSpotifyImageUrlQueryKey = (trackId: string | null,) => {
    return [`/spotify/album_image_url/${trackId}`] as const;
    }

    
export const getGetSpotifyImageUrlQueryOptions = <TData = Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError = AxiosError<HTTPValidationError>>(trackId: string | null, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpotifyImageUrlQueryKey(trackId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpotifyImageUrl>>> = ({ signal }) => getSpotifyImageUrl(trackId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(trackId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpotifyImageUrlQueryResult = NonNullable<Awaited<ReturnType<typeof getSpotifyImageUrl>>>
export type GetSpotifyImageUrlQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Spotify Image Url
 */
export const useGetSpotifyImageUrl = <TData = Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError = AxiosError<HTTPValidationError>>(
 trackId: string | null, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSpotifyImageUrl>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpotifyImageUrlQueryOptions(trackId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Spotify Save Recent Tracks To Database
 */
export const spotifySaveRecentTracksToDatabase = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.post(
      `/spotify/save_recent_tracks_to_database`,undefined,options
    );
  }



export const getSpotifySaveRecentTracksToDatabaseMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof spotifySaveRecentTracksToDatabase>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof spotifySaveRecentTracksToDatabase>>, TError,void, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof spotifySaveRecentTracksToDatabase>>, void> = () => {
          

          return  spotifySaveRecentTracksToDatabase(axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type SpotifySaveRecentTracksToDatabaseMutationResult = NonNullable<Awaited<ReturnType<typeof spotifySaveRecentTracksToDatabase>>>
    
    export type SpotifySaveRecentTracksToDatabaseMutationError = AxiosError<unknown>

    /**
 * @summary Spotify Save Recent Tracks To Database
 */
export const useSpotifySaveRecentTracksToDatabase = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof spotifySaveRecentTracksToDatabase>>, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getSpotifySaveRecentTracksToDatabaseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Joplin Sync
 */
export const joplinSync = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoplinSync200>> => {
    
    return axios.post(
      `/joplin/sync`,undefined,options
    );
  }



export const getJoplinSyncMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,void, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinSync>>, void> = () => {
          

          return  joplinSync(axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type JoplinSyncMutationResult = NonNullable<Awaited<ReturnType<typeof joplinSync>>>
    
    export type JoplinSyncMutationError = AxiosError<unknown>

    /**
 * @summary Joplin Sync
 */
export const useJoplinSync = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinSync>>, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getJoplinSyncMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Joplin Get Note Id
 */
export const joplinGetNoteId = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.get(
      `/joplin/get_note_id/${dt}`,options
    );
  }


export const getJoplinGetNoteIdQueryKey = (dt: string,) => {
    return [`/joplin/get_note_id/${dt}`] as const;
    }

    
export const getJoplinGetNoteIdQueryOptions = <TData = Awaited<ReturnType<typeof joplinGetNoteId>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJoplinGetNoteIdQueryKey(dt);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof joplinGetNoteId>>> = ({ signal }) => joplinGetNoteId(dt, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData> & { queryKey: QueryKey }
}

export type JoplinGetNoteIdQueryResult = NonNullable<Awaited<ReturnType<typeof joplinGetNoteId>>>
export type JoplinGetNoteIdQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Joplin Get Note Id
 */
export const useJoplinGetNoteId = <TData = Awaited<ReturnType<typeof joplinGetNoteId>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNoteId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJoplinGetNoteIdQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Joplin Init Note
 */
export const joplinInitNote = (
    dt: string,
    params?: JoplinInitNoteParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoplinInitNote200>> => {
    
    return axios.post(
      `/joplin/init_note/${dt}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getJoplinInitNoteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinInitNote>>, {dt: string;params?: JoplinInitNoteParams}> = (props) => {
          const {dt,params} = props ?? {};

          return  joplinInitNote(dt,params,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type JoplinInitNoteMutationResult = NonNullable<Awaited<ReturnType<typeof joplinInitNote>>>
    
    export type JoplinInitNoteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Joplin Init Note
 */
export const useJoplinInitNote = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinInitNote>>, TError,{dt: string;params?: JoplinInitNoteParams}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getJoplinInitNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Day Init Markdown
 */
export const dayInitMarkdown = (
    dt: string,
    params?: DayInitMarkdownParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DayInitMarkdown200>> => {
    
    return axios.get(
      `/day_init_markdown/${dt}`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getDayInitMarkdownQueryKey = (dt: string,
    params?: DayInitMarkdownParams,) => {
    return [`/day_init_markdown/${dt}`, ...(params ? [params]: [])] as const;
    }

    
export const getDayInitMarkdownQueryOptions = <TData = Awaited<ReturnType<typeof dayInitMarkdown>>, TError = AxiosError<HTTPValidationError>>(dt: string,
    params?: DayInitMarkdownParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof dayInitMarkdown>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDayInitMarkdownQueryKey(dt,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dayInitMarkdown>>> = ({ signal }) => dayInitMarkdown(dt,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dayInitMarkdown>>, TError, TData> & { queryKey: QueryKey }
}

export type DayInitMarkdownQueryResult = NonNullable<Awaited<ReturnType<typeof dayInitMarkdown>>>
export type DayInitMarkdownQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Day Init Markdown
 */
export const useDayInitMarkdown = <TData = Awaited<ReturnType<typeof dayInitMarkdown>>, TError = AxiosError<HTTPValidationError>>(
 dt: string,
    params?: DayInitMarkdownParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof dayInitMarkdown>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getDayInitMarkdownQueryOptions(dt,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Joplin Get Note
 */
export const joplinGetNote = (
    noteId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoplinNote>> => {
    
    return axios.get(
      `/joplin/get_note/${noteId}`,options
    );
  }


export const getJoplinGetNoteQueryKey = (noteId: string,) => {
    return [`/joplin/get_note/${noteId}`] as const;
    }

    
export const getJoplinGetNoteQueryOptions = <TData = Awaited<ReturnType<typeof joplinGetNote>>, TError = AxiosError<HTTPValidationError>>(noteId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJoplinGetNoteQueryKey(noteId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof joplinGetNote>>> = ({ signal }) => joplinGetNote(noteId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(noteId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData> & { queryKey: QueryKey }
}

export type JoplinGetNoteQueryResult = NonNullable<Awaited<ReturnType<typeof joplinGetNote>>>
export type JoplinGetNoteQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Joplin Get Note
 */
export const useJoplinGetNote = <TData = Awaited<ReturnType<typeof joplinGetNote>>, TError = AxiosError<HTTPValidationError>>(
 noteId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof joplinGetNote>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getJoplinGetNoteQueryOptions(noteId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Joplin Update Note
 */
export const joplinUpdateNote = (
    dt: string,
    params?: JoplinUpdateNoteParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<JoplinUpdateNote200>> => {
    
    return axios.post(
      `/joplin/update_note/${dt}`,undefined,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getJoplinUpdateNoteMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof joplinUpdateNote>>, {dt: string;params?: JoplinUpdateNoteParams}> = (props) => {
          const {dt,params} = props ?? {};

          return  joplinUpdateNote(dt,params,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type JoplinUpdateNoteMutationResult = NonNullable<Awaited<ReturnType<typeof joplinUpdateNote>>>
    
    export type JoplinUpdateNoteMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Joplin Update Note
 */
export const useJoplinUpdateNote = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof joplinUpdateNote>>, TError,{dt: string;params?: JoplinUpdateNoteParams}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getJoplinUpdateNoteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Google Photos Thumbnails Url
 */
export const googlePhotosThumbnailUrls = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GooglePhotosThumbnail[]>> => {
    
    return axios.get(
      `/googlephotos/thumbnails/${dt}`,options
    );
  }


export const getGooglePhotosThumbnailUrlsQueryKey = (dt: string,) => {
    return [`/googlephotos/thumbnails/${dt}`] as const;
    }

    
export const getGooglePhotosThumbnailUrlsQueryOptions = <TData = Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGooglePhotosThumbnailUrlsQueryKey(dt);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>> = ({ signal }) => googlePhotosThumbnailUrls(dt, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData> & { queryKey: QueryKey }
}

export type GooglePhotosThumbnailUrlsQueryResult = NonNullable<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>>
export type GooglePhotosThumbnailUrlsQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Google Photos Thumbnails Url
 */
export const useGooglePhotosThumbnailUrls = <TData = Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof googlePhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGooglePhotosThumbnailUrlsQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Google Photos Add To Joplin
 */
export const googlePhotosAddToJoplin = (
    noteId: string,
    googlePhotosThumbnail: GooglePhotosThumbnail[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GooglePhotosAddToJoplin200>> => {
    
    return axios.post(
      `/googlephotos/add_to_joplin/${noteId}`,
      googlePhotosThumbnail,options
    );
  }



export const getGooglePhotosAddToJoplinMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, {noteId: string;data: GooglePhotosThumbnail[]}> = (props) => {
          const {noteId,data} = props ?? {};

          return  googlePhotosAddToJoplin(noteId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type GooglePhotosAddToJoplinMutationResult = NonNullable<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>>
    export type GooglePhotosAddToJoplinMutationBody = GooglePhotosThumbnail[]
    export type GooglePhotosAddToJoplinMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Google Photos Add To Joplin
 */
export const useGooglePhotosAddToJoplin = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof googlePhotosAddToJoplin>>, TError,{noteId: string;data: GooglePhotosThumbnail[]}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getGooglePhotosAddToJoplinMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Nextcloud Photos Thumbnails Url
 */
export const nextcloudPhotosThumbnailUrls = (
    dt: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    return axios.get(
      `/nextcloud/thumbnails/${dt}`,options
    );
  }


export const getNextcloudPhotosThumbnailUrlsQueryKey = (dt: string,) => {
    return [`/nextcloud/thumbnails/${dt}`] as const;
    }

    
export const getNextcloudPhotosThumbnailUrlsQueryOptions = <TData = Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNextcloudPhotosThumbnailUrlsQueryKey(dt);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>> = ({ signal }) => nextcloudPhotosThumbnailUrls(dt, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dt), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData> & { queryKey: QueryKey }
}

export type NextcloudPhotosThumbnailUrlsQueryResult = NonNullable<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>>
export type NextcloudPhotosThumbnailUrlsQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Nextcloud Photos Thumbnails Url
 */
export const useNextcloudPhotosThumbnailUrls = <TData = Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError = AxiosError<HTTPValidationError>>(
 dt: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof nextcloudPhotosThumbnailUrls>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getNextcloudPhotosThumbnailUrlsQueryOptions(dt,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Nextcloud Thumbnail Dims
 */
export const getNextcloudPhotosThumbnailDims = (
    params: GetNextcloudPhotosThumbnailDimsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<[number, number]>> => {
    
    return axios.get(
      `/nextcloud/thumbnail_dims`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetNextcloudPhotosThumbnailDimsQueryKey = (params: GetNextcloudPhotosThumbnailDimsParams,) => {
    return [`/nextcloud/thumbnail_dims`, ...(params ? [params]: [])] as const;
    }

    
export const getGetNextcloudPhotosThumbnailDimsQueryOptions = <TData = Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError = AxiosError<HTTPValidationError>>(params: GetNextcloudPhotosThumbnailDimsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextcloudPhotosThumbnailDimsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>> = ({ signal }) => getNextcloudPhotosThumbnailDims(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNextcloudPhotosThumbnailDimsQueryResult = NonNullable<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>>
export type GetNextcloudPhotosThumbnailDimsQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Nextcloud Thumbnail Dims
 */
export const useGetNextcloudPhotosThumbnailDims = <TData = Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError = AxiosError<HTTPValidationError>>(
 params: GetNextcloudPhotosThumbnailDimsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudPhotosThumbnailDims>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNextcloudPhotosThumbnailDimsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get Nextcloud Image
 */
export const getNextcloudImageNextcloudThumbnailImgGet = (
    params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetNextcloudImageNextcloudThumbnailImgGet200One>> => {
    
    return axios.get(
      `/nextcloud/thumbnail_img`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetNextcloudImageNextcloudThumbnailImgGetQueryKey = (params: GetNextcloudImageNextcloudThumbnailImgGetParams,) => {
    return [`/nextcloud/thumbnail_img`, ...(params ? [params]: [])] as const;
    }

    
export const getGetNextcloudImageNextcloudThumbnailImgGetQueryOptions = <TData = Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError = AxiosError<HTTPValidationError>>(params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNextcloudImageNextcloudThumbnailImgGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>> = ({ signal }) => getNextcloudImageNextcloudThumbnailImgGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNextcloudImageNextcloudThumbnailImgGetQueryResult = NonNullable<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>>
export type GetNextcloudImageNextcloudThumbnailImgGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Get Nextcloud Image
 */
export const useGetNextcloudImageNextcloudThumbnailImgGet = <TData = Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError = AxiosError<HTTPValidationError>>(
 params: GetNextcloudImageNextcloudThumbnailImgGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNextcloudImageNextcloudThumbnailImgGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNextcloudImageNextcloudThumbnailImgGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Nextcloud Photos Add To Joplin
 */
export const nextcloudPhotosAddToJoplin = (
    noteId: string,
    nextcloudPhotosAddToJoplinBody: string[], options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NextcloudPhotosAddToJoplin200>> => {
    
    return axios.post(
      `/nextcloud/add_to_joplin/${noteId}`,
      nextcloudPhotosAddToJoplinBody,options
    );
  }



export const getNextcloudPhotosAddToJoplinMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, {noteId: string;data: string[]}> = (props) => {
          const {noteId,data} = props ?? {};

          return  nextcloudPhotosAddToJoplin(noteId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type NextcloudPhotosAddToJoplinMutationResult = NonNullable<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>>
    export type NextcloudPhotosAddToJoplinMutationBody = string[]
    export type NextcloudPhotosAddToJoplinMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Nextcloud Photos Add To Joplin
 */
export const useNextcloudPhotosAddToJoplin = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof nextcloudPhotosAddToJoplin>>, TError,{noteId: string;data: string[]}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getNextcloudPhotosAddToJoplinMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create Perform Song
 */
export const createPerformSong = (
    performSongCreate: PerformSongCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    
    return axios.post(
      `/performsongs/`,
      performSongCreate,options
    );
  }



export const getCreatePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPerformSong>>, {data: PerformSongCreate}> = (props) => {
          const {data} = props ?? {};

          return  createPerformSong(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreatePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof createPerformSong>>>
    export type CreatePerformSongMutationBody = PerformSongCreate
    export type CreatePerformSongMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Perform Song
 */
export const useCreatePerformSong = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPerformSong>>, TError,{data: PerformSongCreate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getCreatePerformSongMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Perform Songs
 */
export const readPerformSongsList = (
    params?: ReadPerformSongsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead[]>> => {
    
    return axios.get(
      `/performsongs/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadPerformSongsListQueryKey = (params?: ReadPerformSongsListParams,) => {
    return [`/performsongs/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadPerformSongsListQueryOptions = <TData = Awaited<ReturnType<typeof readPerformSongsList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadPerformSongsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPerformSongsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPerformSongsList>>> = ({ signal }) => readPerformSongsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadPerformSongsListQueryResult = NonNullable<Awaited<ReturnType<typeof readPerformSongsList>>>
export type ReadPerformSongsListQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Perform Songs
 */
export const useReadPerformSongsList = <TData = Awaited<ReturnType<typeof readPerformSongsList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPerformSongsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSongsList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPerformSongsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Perform Song  Count
 */
export const performSongCount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<number>> => {
    
    return axios.get(
      `/performsongs/count`,options
    );
  }


export const getPerformSongCountQueryKey = () => {
    return [`/performsongs/count`] as const;
    }

    
export const getPerformSongCountQueryOptions = <TData = Awaited<ReturnType<typeof performSongCount>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPerformSongCountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof performSongCount>>> = ({ signal }) => performSongCount({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData> & { queryKey: QueryKey }
}

export type PerformSongCountQueryResult = NonNullable<Awaited<ReturnType<typeof performSongCount>>>
export type PerformSongCountQueryError = AxiosError<unknown>

/**
 * @summary Perform Song  Count
 */
export const usePerformSongCount = <TData = Awaited<ReturnType<typeof performSongCount>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof performSongCount>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getPerformSongCountQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Perform Song
 */
export const readPerformSong = (
    performSongId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    
    return axios.get(
      `/performsongs/${performSongId}`,options
    );
  }


export const getReadPerformSongQueryKey = (performSongId: number,) => {
    return [`/performsongs/${performSongId}`] as const;
    }

    
export const getReadPerformSongQueryOptions = <TData = Awaited<ReturnType<typeof readPerformSong>>, TError = AxiosError<HTTPValidationError>>(performSongId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadPerformSongQueryKey(performSongId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readPerformSong>>> = ({ signal }) => readPerformSong(performSongId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(performSongId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadPerformSongQueryResult = NonNullable<Awaited<ReturnType<typeof readPerformSong>>>
export type ReadPerformSongQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Perform Song
 */
export const useReadPerformSong = <TData = Awaited<ReturnType<typeof readPerformSong>>, TError = AxiosError<HTTPValidationError>>(
 performSongId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readPerformSong>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadPerformSongQueryOptions(performSongId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Perform Song
 */
export const updatePerformSong = (
    performSongId: number,
    performSongUpdate: PerformSongUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PerformSongRead>> => {
    
    return axios.patch(
      `/performsongs/${performSongId}`,
      performSongUpdate,options
    );
  }



export const getUpdatePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePerformSong>>, {performSongId: number;data: PerformSongUpdate}> = (props) => {
          const {performSongId,data} = props ?? {};

          return  updatePerformSong(performSongId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdatePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof updatePerformSong>>>
    export type UpdatePerformSongMutationBody = PerformSongUpdate
    export type UpdatePerformSongMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Perform Song
 */
export const useUpdatePerformSong = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updatePerformSong>>, TError,{performSongId: number;data: PerformSongUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getUpdatePerformSongMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Perform Song
 */
export const deletePerformSong = (
    performSongId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeletePerformSong200>> => {
    
    return axios.delete(
      `/performsongs/${performSongId}`,options
    );
  }



export const getDeletePerformSongMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePerformSong>>, {performSongId: number}> = (props) => {
          const {performSongId} = props ?? {};

          return  deletePerformSong(performSongId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeletePerformSongMutationResult = NonNullable<Awaited<ReturnType<typeof deletePerformSong>>>
    
    export type DeletePerformSongMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Perform Song
 */
export const useDeletePerformSong = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePerformSong>>, TError,{performSongId: number}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getDeletePerformSongMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create Dog
 */
export const createDog = (
    dogCreate: DogCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    
    return axios.post(
      `/dogs/`,
      dogCreate,options
    );
  }



export const getCreateDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDog>>, {data: DogCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDog(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateDogMutationResult = NonNullable<Awaited<ReturnType<typeof createDog>>>
    export type CreateDogMutationBody = DogCreate
    export type CreateDogMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Dog
 */
export const useCreateDog = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDog>>, TError,{data: DogCreate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getCreateDogMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Dogs
 */
export const readDogsList = (
    params?: ReadDogsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead[]>> => {
    
    return axios.get(
      `/dogs/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadDogsListQueryKey = (params?: ReadDogsListParams,) => {
    return [`/dogs/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadDogsListQueryOptions = <TData = Awaited<ReturnType<typeof readDogsList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadDogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDogsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDogsList>>> = ({ signal }) => readDogsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadDogsListQueryResult = NonNullable<Awaited<ReturnType<typeof readDogsList>>>
export type ReadDogsListQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Dogs
 */
export const useReadDogsList = <TData = Awaited<ReturnType<typeof readDogsList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadDogsListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDogsList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadDogsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Read Dog
 */
export const readDog = (
    dogId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    
    return axios.get(
      `/dogs/${dogId}`,options
    );
  }


export const getReadDogQueryKey = (dogId: number,) => {
    return [`/dogs/${dogId}`] as const;
    }

    
export const getReadDogQueryOptions = <TData = Awaited<ReturnType<typeof readDog>>, TError = AxiosError<HTTPValidationError>>(dogId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadDogQueryKey(dogId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readDog>>> = ({ signal }) => readDog(dogId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(dogId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadDogQueryResult = NonNullable<Awaited<ReturnType<typeof readDog>>>
export type ReadDogQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Dog
 */
export const useReadDog = <TData = Awaited<ReturnType<typeof readDog>>, TError = AxiosError<HTTPValidationError>>(
 dogId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readDog>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadDogQueryOptions(dogId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Dog
 */
export const updateDog = (
    dogId: number,
    dogUpdate: DogUpdate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DogRead>> => {
    
    return axios.patch(
      `/dogs/${dogId}`,
      dogUpdate,options
    );
  }



export const getUpdateDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDog>>, {dogId: number;data: DogUpdate}> = (props) => {
          const {dogId,data} = props ?? {};

          return  updateDog(dogId,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateDogMutationResult = NonNullable<Awaited<ReturnType<typeof updateDog>>>
    export type UpdateDogMutationBody = DogUpdate
    export type UpdateDogMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Update Dog
 */
export const useUpdateDog = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDog>>, TError,{dogId: number;data: DogUpdate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getUpdateDogMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete Dog
 */
export const deleteDog = (
    dogId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DeleteDog200>> => {
    
    return axios.delete(
      `/dogs/${dogId}`,options
    );
  }



export const getDeleteDogMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDog>>, {dogId: number}> = (props) => {
          const {dogId} = props ?? {};

          return  deleteDog(dogId,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type DeleteDogMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDog>>>
    
    export type DeleteDogMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Delete Dog
 */
export const useDeleteDog = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDog>>, TError,{dogId: number}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getDeleteDogMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create Recipe
 */
export const createRecipe = (
    recipeCreate: RecipeCreate, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RecipeRead>> => {
    
    return axios.post(
      `/recipes/`,
      recipeCreate,options
    );
  }



export const getCreateRecipeMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRecipe>>, {data: RecipeCreate}> = (props) => {
          const {data} = props ?? {};

          return  createRecipe(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateRecipeMutationResult = NonNullable<Awaited<ReturnType<typeof createRecipe>>>
    export type CreateRecipeMutationBody = RecipeCreate
    export type CreateRecipeMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Recipe
 */
export const useCreateRecipe = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRecipe>>, TError,{data: RecipeCreate}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getCreateRecipeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Read Recipes
 */
export const readRecipesList = (
    params?: ReadRecipesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RecipeRead>> => {
    
    return axios.get(
      `/recipes/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getReadRecipesListQueryKey = (params?: ReadRecipesListParams,) => {
    return [`/recipes/`, ...(params ? [params]: [])] as const;
    }

    
export const getReadRecipesListQueryOptions = <TData = Awaited<ReturnType<typeof readRecipesList>>, TError = AxiosError<HTTPValidationError>>(params?: ReadRecipesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadRecipesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readRecipesList>>> = ({ signal }) => readRecipesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadRecipesListQueryResult = NonNullable<Awaited<ReturnType<typeof readRecipesList>>>
export type ReadRecipesListQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Read Recipes
 */
export const useReadRecipesList = <TData = Awaited<ReturnType<typeof readRecipesList>>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadRecipesListParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof readRecipesList>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadRecipesListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Send Api Json
 */
export const sendApiJsonGenerateOpenapiJsonGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SendApiJsonGenerateOpenapiJsonGet200>> => {
    
    return axios.get(
      `/generate_openapi_json`,options
    );
  }


export const getSendApiJsonGenerateOpenapiJsonGetQueryKey = () => {
    return [`/generate_openapi_json`] as const;
    }

    
export const getSendApiJsonGenerateOpenapiJsonGetQueryOptions = <TData = Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSendApiJsonGenerateOpenapiJsonGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>> = ({ signal }) => sendApiJsonGenerateOpenapiJsonGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData> & { queryKey: QueryKey }
}

export type SendApiJsonGenerateOpenapiJsonGetQueryResult = NonNullable<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>>
export type SendApiJsonGenerateOpenapiJsonGetQueryError = AxiosError<unknown>

/**
 * @summary Send Api Json
 */
export const useSendApiJsonGenerateOpenapiJsonGet = <TData = Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSendApiJsonGenerateOpenapiJsonGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




