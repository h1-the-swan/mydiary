/**
 * Generated by orval v6.6.4 üç∫
 * Do not edit manually.
 * mydiary
 * OpenAPI spec version: 0.1.0
 */
import axios,{
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  UseQueryOptions,
  QueryFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
export type ReadPocketArticlesParams = { offset?: number; limit?: number; status?: number[]; tags?: string[]; year?: number };

export type ReadTagsParams = { offset?: number; limit?: number };

export type ReadGCalEventsParams = { offset?: number; limit?: number };

export interface ValidationError {
  loc: string[];
  msg: string;
  type: string;
}

export interface TagRead {
  id: number;
  name: string;
  is_pocket_tag?: boolean;
}

/**
 * An enumeration.
 */
export type PocketStatusEnum = 0 | 1 | 2;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PocketStatusEnum = {
  NUMBER_0: 0 as PocketStatusEnum,
  NUMBER_1: 1 as PocketStatusEnum,
  NUMBER_2: 2 as PocketStatusEnum,
};

export interface PocketArticleRead {
  id: number;
  given_title: string;
  resolved_title: string;
  url: string;
  favorite: boolean;
  status: PocketStatusEnum;
  time_added?: string;
  time_updated?: string;
  time_read?: string;
  time_favorited?: string;
  listen_duration_estimate?: number;
  word_count?: number;
  excerpt?: string;
  top_image_url?: string;
  tags: TagRead[];
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GoogleCalendarEventRead {
  id: string;
  summary: string;
  location?: string;
  description?: string;
  start: string;
  end: string;
  start_timezone: string;
  end_timezone: string;
}



// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


/**
 * @summary Read Gcal Events
 */
export const readGCalEvents = (
    params?: ReadGCalEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GoogleCalendarEventRead[]>> => {
    return axios.get(
      `/gcal/events`,{
        params,
    ...options}
    );
  }


export const getReadGCalEventsQueryKey = (params?: ReadGCalEventsParams,) => [`/gcal/events`, ...(params ? [params]: [])];

    
export const useReadGCalEvents = <TData = AsyncReturnType<typeof readGCalEvents>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadGCalEventsParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readGCalEvents>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadGCalEventsQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readGCalEvents>> = () => readGCalEvents(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readGCalEvents>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


/**
 * @summary Read Tags
 */
export const readTags = (
    params?: ReadTagsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TagRead[]>> => {
    return axios.get(
      `/tags`,{
        params,
    ...options}
    );
  }


export const getReadTagsQueryKey = (params?: ReadTagsParams,) => [`/tags`, ...(params ? [params]: [])];

    
export const useReadTags = <TData = AsyncReturnType<typeof readTags>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadTagsParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readTags>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadTagsQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readTags>> = () => readTags(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readTags>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


/**
 * @summary Read Pocket Articles
 */
export const readPocketArticles = (
    params?: ReadPocketArticlesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PocketArticleRead[]>> => {
    return axios.get(
      `/pocket/articles`,{
        params,
    ...options}
    );
  }


export const getReadPocketArticlesQueryKey = (params?: ReadPocketArticlesParams,) => [`/pocket/articles`, ...(params ? [params]: [])];

    
export const useReadPocketArticles = <TData = AsyncReturnType<typeof readPocketArticles>, TError = AxiosError<HTTPValidationError>>(
 params?: ReadPocketArticlesParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof readPocketArticles>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getReadPocketArticlesQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof readPocketArticles>> = () => readPocketArticles(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof readPocketArticles>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}


